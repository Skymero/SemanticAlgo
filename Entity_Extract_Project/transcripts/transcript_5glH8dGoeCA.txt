hey's up guys My Name Is AO today I'm going to be showing you how to properly set up a C++ project especially one that has this kind of core app architecture which basically means that you have this core library of code and then one or more applications that will use that core library now that by itself is obviously extremely subjective everyone has their own way of doing things and in this video I'm going to be showing you my way of doing things and the use cases for this core app architecture are honestly endless you could use this for so many things I use this architecture when making walnut chat as an example it's like a instant messaging chat client thing and even Hazel my game engine uses this same architecture in fact it's a very very good fit for game engines so in this video we're first going to take a look at how to use this template to make a brand new C++ project but then I'm also going to be showing you how to retrofit an existing project and conform it to this architecture and to this template and we're specifically going to be doing that with the 2000 hour 2D game engine that I have been been code reviewing as part of my code review series for like three videos already because this will greatly improve that now typically when people make new C++ projects if they are either new to programming or to C++ or they're inexperienced or whatever the reason might be a lot of the times they will just open Visual Studio as an example or whatever ID they use and they will click the new solution new project button whatever and just they'll start from there it seems logical like I don't blame anyone for doing that it seems logical and for a lot of cases I'm sure it's fine but there's a better way it's by using my template this sounds like I'm selling this template this template is completely free the link will be in the description below if you want to just skip me talking the problem is that with C++ most of the time you want to be using a build system now a build system really like it's it's a term that that has many definitions potentially because a build system as the name implies is supposed to basically take your raw code files and build it into some kind of product now an example of a build system is cmake cmake will do that I prefer to use something different called premake the name basically explains what it is pre make make itself is a build system the whole idea of make is that you have these things called make files you use them to describe what your project is and how it should be built and then you run make to build the project premake exists as a way to generate make files because make itself is kind of an interesting build system/ language and it can be very veror and potentially difficult to express yourself in make versus something like premake which just uses lure and is much much much simpler now pre-make doesn't just generate make files premake also generates well any kind of project file you really need so for example if you want Visual Studio project files because you're going to be compiling your application or your project on Windows prake can do that for you it will take your lure description of your project and it will generate Visual Studio project files and solution files for you hopefully you're beginning to see the power now because if I instead want xcode files because I want to build this on my Mac or I want I don't know make files because I want to build on Linux I can do all of this there's plenty other supported build systems and Ides as well so that now means that instead of me having to create project files in Visual Studio by using the UI and then having them only work on Windows or at least only work in Visual Studio I can create create all of the build configuration files for my entire project in premake and then have premake generate whatever project files I need so that is what premake is we've been using it since the beginning for Hazel and it's been it's been really good and this template also uses premake to generate all of the project files which is one of the reasons why this template is a fantastic starting point for crossplatform applications now before we dive in and take a look at this template and I show you how to start a brand new simp plus project using it if you want to learn computer science and math then there's an excellent free way you can do that with the sponsor of this video brilliant.org brilliant.org is an amazing website filled with lots and lots of courses on various stem topics now as I mentioned they're an excellent place to start learning computer science because all of their courses are just really clean and fun and efficient at teaching you instead of just watching like boring lectures with zero engagement you instead have these widgets that you can play with that that show you how things work I think their math courses are a fantastic example of this cuz you can see like for example with Calculus how stuff works visually and you can play with it to see how the numbers actually reflect how it works but then also they'll quiz you they'll ask you questions to make sure that you are actually learning something and that you can answer those questions and the range of how advanced their courses are they go down all the way to the beginning with the Everyday Math course which is a fantastic place to just ease into math all the way up to like linear algebra and calculus and guess what you can take a look at all of this for free brilliant have a 30-day free trial that you can use to check out everything they have to offer just go to brilli ./ Theo link will be in the description below and if you do go on to like it brilliant have been nice enough to offer the first 200 subscribers 20% off an annual membership huge thank you to brilliant.org as always for sponsoring this video okay so here is the C++ project St template the link will be in the description below I've spent a little bit of time here on this ra me so that you can read it that's what a read me is for but the easiest way to use this is to click this use this template button because that just lets you create a new repository with this as like the starting content so let's actually go ahead and do that I'm going to just call this new project I'll make it private I'll click create repository this won't take very long and then here we have our brand new repository it's called new project it's generated from Project template and now what I can do is I can just clone this so I've got this local folder here we can just do get clone and then paste the URL there we go we've got all of it let's open it and this is it you're you're ready to go so the most important thing you need to know is that inside the scripts directory there is a setup Windows batch file there's also one for Linux as well didn't get around to making one for Mac OS but I'm sure that's not too difficult so all we have to do is just double click on this batch file you can see it's going to run premake here and then if we go out you'll see that we have a new project solution file so this is in the root of this project so if we open it here we have in Visual Studio what this looks like so we've got an app project we've got a core folder inside the core folder there is this core project we've got some example files just some starter content so inside app you can see I'm just calling something from core a function called print hello world which will'll just do this so if we just hit F5 on that there you go we've got we've got an application mindblowing I know now hear me out I actually think this is a lot faster than if you set this up in Visual Studio yourself if you did set this up in Visual Studio there'd be a lot more clicking and it would be Visual Studio only whereas with this template we have this great architecture here where you can see app references core so I'm I'm ready to go on that front I have debug disc and release configurations already set up and as you saw I can also generate these project files on Linux just into make files and then use make to to build this or I could really generate whatever else preix supports so so that's kind of it that's ready to go out of the box now you might not want this to be called new project so how can we edit this and how does it work in the first place so in the route we have this build. L file by the way the GitHub read me explains all of this so you can just read that if you want but since we're here I'll show you so build. L if we open that up you can see I should probably get rid of this commment whoops you can see that we have a workspace definition so this defines kind of like our Visual Studio solution you can put some workspace wide build options here I've just put some ones that we commonly use on Hazel you can set a more custom output directory because by default it'll be in binaries and then the platform name the configuration name and then the project name so if you don't like that you can change it here here are the solution configurations and the architecture and the start project if you want to change this to some other name like orange let's call it project orange if we go back to the root here we have app and core so if this was my like I don't know orange core let me just maybe close this first and orange app inside these two folders are where those projects go so my core project is in here here's that vcx project file generated from earlier here's all of my source files inside the source directory and here is the lure file that tell us premake how to build this project or how to generate project files for this project so if we open this up inside a text editor then here we have all of the Project Specific configuration so here's the name for example it's called core so let me change that to Orange core that might be something you want to customize the version of C++ as an example you could also change this by the way to C so this doesn't just have to be used for C++ but that is the the common use case for it which files you want to include so I might actually change this a little bit because at the moment it only supports hcpp which is what I use commonly however if you use like HPP or cxx or you want C files as well like you can add all of these here might make more sense to to make it into something that looks like this in that case there's the compiler include directories here I mean really if you want to set this up you can see that there's specific things for Windows or specific settings for debug release or distribution configurations if you want to see what's possible you can just check out the pre-make documentation I'll leave a link to that in the description below so that's orange core if we go back out we have orange app same story with that as well you can see that we have a project called app which I can rename to Orange core you can see by the way that this is a console app whilst orange core is a static library and also orange app which I accidentally called orange core uh links to core so we need to update this as well cuz that's the name and then if we want the include path to also work we have to update that you can also just use variables that's fine but typically project names don't change that often so I usually don't bother okay so now back in the original build file so this is like the one for the for the solution or the workspace we just need to make sure that we're including the right directories here so we can call this orange core and orange app and if I go back and just rerun that setup file it should regenerate all the projects now you can see I have project orange being the solution file and then if I open that I have orange core and orange app the one thing I did forget to change is the start project so over here inside the build you can see the start project is still app that's why it incorrectly set this one as the start project cuz it didn't find one called app so let's get rid of that and then if I just delete everything all of the generated project files and rerun this open up the solution file then you should see orange app as the startup project and we should be able to run this as normal Okay cool so yeah that's really all there is to it it's just a really nice starting point if you want to have a C++ project with this architecture and so now let's have a look at how we can apply this to an existing project which is not using this it's not just using no build system or no project generation system just raw Visual Studio project files it's also not using this architecture at all there is no app and core distinction It all becomes part of a single Visual Studio project so we're going to apply this to that and fix all of that up and hopefully make it a lot better all right so here we have the project that we're going to be applying this magic to this is the 2000 hour game engine that I've been code reviewing it's part of my code review series link to this project will be in the description below again we're just using it as an example because it happens to not have this architecture implemented and also doesn't happen to have a build system at all implemented so I've checked out the project locally here it is on disk this is the root of the repository if we go into the engine folder there's just a Sprite Engine Solution file and if we open that we are graded with this so we have a Sprite engine project just a single project in this entire solution and then inside here we have the engine but also this project itself if we take a look at the properties you can see it builds into an executable file and this is the editor for the project so you can see here if I look at the main file with the main function it starts off with a UI project selector and this is where you can open whatever project you want and then it runs the engine and essentially the editor for this engine now what about the games what if you want to just run the game so inside the Resources directory and template there's another solution called assets and if we open this this solution you can see that it again has a single project and it's just called assets and that has some kind of subset of the game engines source files so you can see there is also a main file looks similar but it doesn't have that UI project selector and then if we open up the base Engine Solution which is the editor if we take a look at these Source directory side by side here you can see that this one doesn't have for example a GUI components section at all and I think everything else looks pretty much the same but see like in manager there's a GUI manager here I don't know if it's just in a different okay so it's here but it's not included cuz I'm in show files mode sure so there are some differences as you would expect because one of the project files builds into the runtime one of the project files builds into the editor so there have to be some differences and they're definitely here but what's really annoying about this approach which I talked about in those code review videos is this basically the fact that since you have two different projects all of these settings are obviously per project right so these settings and these settings they're two different projects that need the exact same settings more or less anytime you want to link a new library anytime you want to add an include directory anytime you want to add like a pre-processor definition that has to happen in both of those projects and in fact every time you want to add a file I just want to add a new CPP file well if you wanted to compile for both the game and the editor as part of the engine then you have to manually add it to both project files which is very inconvenient so part of the way that this core app architecture helps you here is that we can group all of this common code into that core project and then have two different app projects one which is this assets project which is the game The Game's runtime and then one which is this Sprite engine project which is the editor in those projects that falls under the app project category we would have things that are specific to those applications and those projects but then everything else that is core that is Central to both of those applications would be inside that core library inside that core project now as an example when we have something like GUI components which is specifically part of the editor in this case cuz it doesn't exist over here inside the game project that could simply just live inside that app project that we'll make not inside core because it's not going to be Central in more specific setups this hierarchy of like we have core and we have app can definitely be extended by the way so you could make another static library in between core and app that's called like GUI components and then that way if you do need to reuse that code you can reuse it in multiple applications so maybe you have an editor but then maybe you also have some kind of other tool that needs to use GUI that would be a great example of making like a GUI components project in between core and app so that you can reuse that code and then the game project which doesn't need that would simply Direct directly linked to core so again I want to stress this template is just a starting point and you can definitely extend it okay so here we have my project template all you have to do is clone that somewhere I'm not going to spend too much time on this here because we've already covered this earlier in the video but here I have the physical files on disk what I'm going to do from here just as a starting point is just copy all of these files into this Sprite engine UI project and I'm going to have a look here as to where I want this to live because there's this GitHub directory with a couple images and then there's the engine and I'm assuming this person is trading the engine is like the root directory so I think this would be a good place for this to be pasted into we don't need to get ignore and the read me and the unlicensed I'm just going to delete all of that so now we can really begin customizing this stuff so the source directory includes all of the stuff that is relevant to the engine but then there's also this Sprite engine file and GUI components which seems to be only relevant for the editor so as a starting point I'm just going to grab everything inside the source directory cut it put it into core and then Source I'm going to delete this St a content content that we had here paste that in there so now it's in here now I'm going to rename core to Sprite engine core and then app I'm going to call Sprite engine editor and I'm going to copy and paste that folder and just call it Sprite engine runtime so we've got the core we've got the editor and we've got the runtime three different projects now if I open this build. L file in a text editor that's the one that's in the root of this project I've got a group here called core which runs build core we've changed this directory name so I'm just going to make sure we do that and then we've got Sprite engine editor and runtime so I'm just going to make sure that we have two of these one's going to be inside Sprite engine editor I might call this something like build editor so we'll have to rename that lure file as well and then we also have Sprite engine runtime and I'm going to call this build runtime other than that that looks pretty good I'm pretty happy with that the start project we might make um the editor so we'll have to name the project that as well and then coming back into here let's start with core I'm going to go ahead and open this so over here let's go ahead and call this project Sprite engine core by the way we should probably name the workspace something thing I'll just call it Sprite engine so what I'm doing here is I'm making a workspace but I've got two different projects tied into that workspace well two different executables and then one core Library you could make two different solution files as well if you wanted to you could just have another workspace called like Sprite engine run time and then another one called Sprite engine editor that way you don't have to have them all inside one solution if you don't want to I prefer having them all inside one solution because then you can easily switch between the editor and the runtime as you're developing the engine so I'm going to leave it this way but if you wanted two different Solutions you could also set that up pretty easily so here's Sprite engine cord that's going to be a static Library just going to include everything inside here I'm going to set it as an include directory most of these settings are pretty straightforward and Universal like I don't really need to change anything at all so if we go back now I just need to make sure that build core is called the right thing so it is build core but then we'll have to just rename editor and runtime this is called build app so let's rename it to build editor. lure we'll go ahead and open it the project name I'm going to call Sprite engine editor it's going to be a console app now if you wanted to you could make it so that under filter distribution it was set to uh Window app so I actually had to open up the pre-make documentation here but you can see these are the the possible values of kind so we're using static Library if you wanted a DL you could use Shar lib instead and then console app is just an application with an actual console being allocated and then if you didn't want that you could have it set to Window app so Hazel for example has release and debug set to to console app because we use those two configurations in development but then the distribution configuration is set to Window app so that's where these filters really do come in handy as well now we have to include the core directory if we want to be able to include those files so I think the directory is just Sprite engine core and I think that's like for now that's probably it if I go back we'll just have to do the same thing with the runtime so we'll call it build runtime we'll pop that in here and then I'll just make sure that we have that same include directory as well as the project being called Sprite engine runtime uh the other thing is what it links so it needs to link the Sprite engine core project so you need to get that name right obviously so Sprite engine core is what both of these guys need to link uh and then I think that's it honestly for the project configuration if you separate the files into their proper directories meaning the stuff that's relevant to the editor you put into editor and vice versa you shouldn't really have to do anything specific here another thing we could have done is just ignored certain files so you can include an entire directory but then exclude files as well that can be useful under certain configurations if you don't want to include debug files inside a disc build for example but we're not going to cover that here because it's just not relevant back inside core I want to have a look at the GUI components and then also this Sprite engine file because this Sprite engine file is the thing that launches this UI project selector because it's the editor so this obviously shouldn't be in core it should be inside that editor project so I'm going to grab Sprite engine. CPP and GUI components this file in this folder I'm going to cut this and I'm going to put it into Sprite engine editor source so there's we'll delete app Dopp which is just like the starter content and we'll paste that in I probably rename this file to something like Sprite engine editor as an example but this is what contains the main function for this executable project so that's inside source that's great now we need to do the same thing for runtime but remember that that's inside like resources template engine I guess source and then here's the main so I'm assuming these are the same like we might have to grab header know of headers necessary but let's grab main I'm just going to open up another view here we'll go back to Sprite engine runtime Source we'll delete app we'll paste this in we'll call this Sprite engine runtime instead of just main now going back here though uh header was header something that we had inside the core engine no so I'm assuming we probably want that I don't know what's inside there but I can see that it's just in the runtime so we'll paste that in and we'll see what happens that was probably an include directory by the way the way I'm doing this is like this is a fair small project so I don't really need to stress too much but if I was trying to do this a little bit more accurately perhaps there's a couple ways I could go about that first of all if we go into this template solution I could open this as well as dropping in this vcx Pro into a text editor just to see exactly you know what files are included in the build what pre-processor definitions there are for various things it's potentially a little bit easier to just look at the text here and you can see like for example what it links which we're going to have to set up as well obviously L but you can also do that just using the UI if you prefer so if I go into cc++ there's additional include directories and you can see these are the include directories that are necessary so I obviously need to make sure that these are all set up correctly as well as inside Linker there's going to be the additional Library directories which I'm going to need to include as well and then under input there are all of these files all of these Library files that need to get linked and there are different variants so you can see these have /d for debug but then if we switch to release there's no - D sorry I said SL D I meant - d That's not in these ones so that's another example where we would use filters but before we do linking let's do compiling first that's a good way to break this down otherwise it's just too much at once so in this runtime project if I just go over here I know that I'm going to need all of these directories included and that's going to be relative to the solution directory which is this directory over here with that solution file so we have engine and then we have the source directory and that's included as well as source include as well as scripts as well as source include I am goey so let's go back to build runtime over here I'm just going to move it here so I can see these two and then into this include directory I've already got Sprite engine core source which is this directory up here so let's duplicate that a couple times and we're going to have source include now this scripts directory is not part of the engine it's inside assets we'll take a look at that in a minute but we also have source include I am goey as an include directory so we'll add that and then we have scripts So What on earth is in scripts scripts doesn't actually exist at the moment scripts is probably the directory for like user scripts so if if your game has custom CPP files I imagine that's what that is because I think C++ is used as a scripting language so if you wanted that you could of course also have this here as an example so I'll just leave that for now and then let's also make sure that we have all of the ones that are inside the engine so if we open up the engine solution and we take a look at these property Pages then we have all of these guys so let's go ahead and include all of this and you can see there's some stuff here that's relative to GUI components and some stuff here that is relevant to uh the actual engine so this is also by the way where I should mention that it can get a little bit difficult to discern what is part of the engine and what is part of the app so what's core what's app because they're all in one project right so I actually don't know if include IM guey for example is necessary for the app like it might just be something that the core Library needs and same with include like I don't know include sounds like it should be included Source I guess as well but if we go back into the core what I'm going to do is make sure that we also have Source SL include include and source include I am guey and Source headers so source include I am guey and Source headers so we're putting these include directories into the actual core library because I'm assuming that the CPP files there would need these include parts to build and then if we go into the editor configuration file then these gii component ones are probably going to be there and again some subset of these possibly all of them I don't know so let's just add I guess all of them so source include include I am goey Source headers and then we have a bunch of stuff that's gii components which remember is in our project now not inside core so Source gii components property editor real time editor project selector okay that looks good um if we take a look at the pre-processor so again I'm just focusing on compiling first not linking yet so this tab is what I'm interested in not the link up so inside pre-processor I also want to make sure that these are set I guess debug and console and then we have n debug and console I don't know if they're actually used by this project cuz these are kind of Visual Studio default pre-processor definitions but if you wanted to add these two then obviously into either debug or release we could add them so for example release see I've got release as just a a default Define but doesn't look like we need it so we can just replace it with n debug and then this one would have underscore debug and then disc we don't really have a disc to begin with and then there's also underscore console that's used in all of these configurations so we could just pop it down somewhere up here like so and there we go so let's make sure that build runtime also has this and build core has this and then this n debug uncore debug stuff I'm also going to make sure that we have inside the other projects and I think that should be it as far as compiling goes obviously it's not going to link but it should be a good starting point so if we go back to the rot uh and actually inside the engine directory where we have this script directory if we go ahead and take a look at what setup Windows does you can see it goes back a directory and then calls this the file it's going to run is build. L and it's going to generate Visual Studio 2022 solution and project file so that sounds pretty good I think that should probably work so let's go ahead and run this there we go so you can see it's generated core editor and runtime project files as well as the Sprite Engine Solution file so if we go back we now should have Sprite engine with a space which is good cuz otherwise it would have overwritten this one so let's double click on this and this is our brand new solution so over here you can see we have Sprite engine editor as a start project which is great we got core with all the stuff that's included inside core and then we've got editor just with gii components and this Sprite engine editor file as well as Sprite engine runtime with that headed directory which I don't know if we actually need but sure and then we've got Sprite engine runtime here as well so we got a few errors that looks like but let's go ahead and build core first of all I'll right click and hit build again this isn't going to link at all because this is just a static Library so we're just going to make sure that our stuff is set up correctly which you can see it's not so UI tool buttons model seems like it's necessary by Sprite repository which is weird cuz I thought that it wasn't being used because I guess this is something that is inside GUI components but it's also inside Sprite repository which is a very core file as we learned from the code review videos and see there's like editor Tools in here so this might require a little bit more work to actually properly segregate but what I want to do is I want to go back to this template cuz are these files actually different imagine if they were different so Sprite repository. it's located over over here inside manager let's take a look at it here oh man it's a different file look it doesn't have that these are full on different files H okay so that's definitely putting a dent into this I mean they're probably not that different but you can see editor tools isn't um included in here it's got it looks like it's basically the same thing but editor tools you can see is not in here now I'm expecting that the CPP file is also going to be different because obviously if this is a member variable I'm assuming it's going to be used here somewhere we go back to core and we take a look at Sprite repository CP inside core you can see there's current tool and then well it's not really used inside here but it is set here now fundamentally I have no idea why Sprite repository which is supposed to be essentially a data structure would have an editor tool inside it that again is not a very good design and you can see why it's leading to problems here where we have to have two different Sprite repositories where the only difference really seems to be this current tool and there's also this initialized kind of word that's that's missing and otherwise I think they're pretty much the same the same file I could definitely make an entire video talking about how to set this up properly so that you could have specific variance potentially of this that only were used for a particular project but then not another project so for example like for the editor but not for the runtime now there's some other uh problems here and you can see that actually a lot of this seems to just rely on this gii components even though I really thought it was excluded let's go back to the template for a second and we'll open up this solution did these just not have any mention of GUI there's GUI manager here but I guess that doesn't but I guess GUI components yeah it doesn't exist inside the solution wow so every single file that was in here has a variant has another copy of that file that just has this stuff manually stripped out which means that if you if you update any code inside game engine what so there's two different game engine files sorry this is turning into a bit of a code review but if I go back into here and this is game engine Doh here it just doesn't have that what so these are just fundamentally different what do I do here I actually don't know what to do here so I guess this is a good example of where it can be a little bit difficult to retrofit this core app architecture when you have gone down the two different paths too far I think from here there are a few different approaches you could honestly take the better solution would just be to to set this up completely differently where you don't have two identical classes that have to have different code depending on if it's the editor or the runtime but instead all of your truly common code like this renderer I mean you can see even just the namespace is different well actually no they're both in that namespace but this just has this for some reason but anyway you would have the common functionality inside say game engine and then the stuff that is relevant to the editor would just be in like the editor application file which could be a number of things it could be it could even be a subass of this it doesn't have to be but yeah I honestly had no idea that these files were so actually different I just thought I just thought this project had a different subset of files so if we paste back this GUI components as an example and let's just go ahead and rerun the setup script to regenerate this project I'm assuming now it will probably build unless we need yeah so you can see there's also the include path here so going back into core we need to make sure that I guess all of these are also include directories inside core if we wanted to build and then let's rerun that and then let's try and build that okay so we got an error over here now okay I have real time editor editor here for some reason whoops let's rerun that again and there's some other errors that we have here to iron out I think this is upset about chart 8T cuz this is u8 it's probably a C++ version thing one thing I forgot to mention is that this we set to C++ 20 right so that the the template by default comes with C++ 20 as the CPP dialect the cppp version but if we look at the original it's C++ 17 so that's definitely something you want to get right otherwise you might have issues like we are seeing here so let's regenerate that again if I try and build this file you can see this file succeeds let's try and build the rest of the engine we're getting there we're getting there do we have any errors no here I'm  seems to be building as well which means our include directories are set up correctly and there we we go we've successfully built this as a static Library so I hope this was helpful to you if you want to retrofit this potentially into an existing project there's still quite a bit of work for this specific project to get it to work properly with this new architecture considering that it is just a mess when it comes to the way that it's set up to eventually build into two different products if you would like to see more videos on me fixing this project and bringing it into this architecture and just setting it up properly in this in this more robust way definitely let me know in the comments section below but otherwise I hope you guys do enjoy my template if you enjoyed this video please don't forget to hit the like button link to the template will be in the description below it's just freely available on GitHub and the license is just unlicensed so feel free to do whatever you want with it don't forget to check out brilliant.org Theo and I will see you guys next time goodbye 